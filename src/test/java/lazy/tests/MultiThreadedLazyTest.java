package lazy.tests;

import lazy.Lazy;
import lazy.LazyFactory;
import org.junit.Test;

import java.util.LinkedList;
import java.util.List;
import java.util.function.Supplier;

/**
 * Test set for thread-safe implementation of {@link lazy.Lazy}
 * generated by {@link lazy.LazyFactory#createLazyMultiThreaded(Supplier)}
 */
public class MultiThreadedLazyTest extends LazyTest {
    /**
     * Thread count to use in {@link this.testMultiThreadedCalls}
     * Currently set to 5 -- pretty standard number, which corresponds to usual number of CPU cores + 1
     */
    private static final int THREADS_TO_TEST = 5;

    protected <T> Lazy<T> applyLazyFactoryGenerator(Supplier<T> supplier) {
        return LazyFactory.createLazyMultiThreaded(supplier);
    }

    private <T> void testMultiThreadedSubsequentCall(Supplier<T> supplier) throws InterruptedException {
        Lazy<T> lazy = applyLazyFactoryGenerator(supplier);
        T expectedResult = supplier.get();
        List<Thread> threads = new LinkedList<>();
        for (int i = 0; i < THREADS_TO_TEST; ++i) {
            threads.add(new Thread(() -> testSubsequentCall(lazy, expectedResult)));
        }
        for (Thread thread : threads) {
            thread.join();
        }
    }

    /**
     * Check that current implementation of {@link lazy.Lazy} is really thread-safe
     * @throws InterruptedException if any of the test threads is interrupted
     */
    @Test
    public void testMultiThreadedCalls() throws InterruptedException {
        testMultiThreadedSubsequentCall(SIMPLE_SUPPLIER);
        testMultiThreadedSubsequentCall(NULL_SUPPLIER);
        testMultiThreadedSubsequentCall(LONG_COMPUTATION);
    }
}